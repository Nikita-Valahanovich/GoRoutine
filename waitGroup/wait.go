package main

import (
	"fmt"
	"sync"
	"time"
)

// writer - паттерн генератор, создает канал только на чтение из него
// В паттерне генератора нельзя блочить основной поток, между
// созданием канала и его возвращением
func writer() <-chan int {
	ch := make(chan int) // Создаем канал для передачи int
	wg := &sync.WaitGroup{}

	wg.Add(2)
	go func() {
		defer wg.Done()
		for i := 0; i < 5; i++ { // Цикл от 0 до 9 (всего 10 итераций)
			ch <- i + 1 // Отправляем в канал числа от 1 до 10
		}
	}()

	go func() {
		defer wg.Done()
		for i := 0; i < 5; i++ { // Цикл от 0 до 9 (всего 10 итераций)
			ch <- i + 11 // Отправляем в канал числа от 1 до 10
		}
	}()

	// Создаем новую горутину, в которой дожидаемся завершения предыдущих двух
	go func() {
		wg.Wait() // дожидаемся завершения 2х горутин
		close(ch) // после этого закрываем канал
	}()

	return ch // Возвращаем канал как только для чтения
}

func main() {
	ch := writer() // Получаем канал от функции writer

	// Читаем из канала до его закрытия в бесконечном цикле
	for {
		v, ok := <-ch // ok = false, когда канал закрыт
		if !ok {
			break // Выходим из цикла, если канал закрыт
		}
		fmt.Println("v=", v) // Выводим значение
	}

	time.Sleep(1 * time.Second)
}
